name: Windows RDP via ngrok

on:
  workflow_dispatch:
    inputs:
      keep_alive:
        description: 'Keep session alive until timeout'
        required: false
        default: 'true'
        type: boolean
  # Trigger temporaire pour faire apparaître le workflow - à supprimer après
  push:
    branches: [ main ]
    paths: [ '.github/workflows/rdp-setup.yml' ]

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 9999

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download ngrok
      run: |
        Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile "ngrok.zip"
        Expand-Archive -Path "ngrok.zip" -DestinationPath "." -Force
        Remove-Item "ngrok.zip"

    - name: Setup ngrok auth
      run: |
        .\ngrok.exe config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    - name: Enable RDP
      run: |
        # Activer le Remote Desktop
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -Value 0
        
        # Activer RDP à travers le firewall
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        
        # Configurer l'authentification au niveau du réseau (optionnel)
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -Value 1

    - name: Create RDP user
      run: |
        # Créer un utilisateur pour RDP
        net user rdpuser "${{ secrets.RDP_PASSWORD }}" /add
        net localgroup administrators rdpuser /add
        net localgroup "Remote Desktop Users" rdpuser /add

    - name: Get system info
      run: |
        Write-Host "=== System Information ==="
        Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion, TotalPhysicalMemory
        Write-Host "=== Network Configuration ==="
        Get-NetAdapter | Where-Object Status -eq "Up" | Select-Object Name, InterfaceDescription, LinkSpeed

    - name: Start ngrok tunnel
      run: |
        Write-Host "Starting ngrok tunnel..."
        Start-Process -FilePath ".\ngrok.exe" -ArgumentList "tcp 3389 --log stdout" -NoNewWindow
        Start-Sleep -Seconds 10

    - name: Get ngrok tunnel info
      run: |
        try {
          $response = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels"
          $tunnel = $response.tunnels | Where-Object { $_.proto -eq "tcp" } | Select-Object -First 1
          if ($tunnel) {
            Write-Host "=== RDP CONNECTION INFO ==="
            Write-Host "Host: $($tunnel.public_url.Replace('tcp://', ''))"
            Write-Host "Username: rdpuser"
            Write-Host "Password: [PROTECTED - Check repository secrets]"
            Write-Host "=========================="
            
            # Sauvegarder les informations dans un fichier
            $connectionInfo = "=== RDP CONNECTION INFO ===`nHost: $($tunnel.public_url.Replace('tcp://', ''))`nUsername: rdpuser`nPassword: [PROTECTED - Check repository secrets]`n============================"
            $connectionInfo | Out-File -FilePath "rdp_connection_info.txt"
          } else {
            Write-Host "No TCP tunnel found"
          }
        } catch {
          Write-Host "Error getting tunnel info: $($_.Exception.Message)"
        }

    - name: Keep alive
      run: |
        Write-Host "Session will remain active until GitHub Actions timeout (6 hours max)"
        Write-Host "RDP session is ready. Use the connection info above to connect."
        Write-Host "=== MONITORING SESSION ==="
        
        $startTime = Get-Date
        $counter = 0
        
        # Boucle infinie jusqu'à timeout GitHub Actions
        while ($true) {
          $currentTime = Get-Date
          $elapsed = $currentTime - $startTime
          $counter++
          
          Write-Host "[$($currentTime.ToString('HH:mm:ss'))] Session active - Elapsed: $($elapsed.ToString('hh\:mm\:ss'))"
          
          # Vérifier le tunnel toutes les 5 minutes (tous les 5 cycles)
          if ($counter % 5 -eq 0) {
            try {
              $tunnelResponse = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -TimeoutSec 10 -ErrorAction Stop
              $activeTunnel = $tunnelResponse.tunnels | Where-Object { $_.proto -eq "tcp" -and $_.public_url -like "*ngrok*" }
              
              if ($activeTunnel) {
                Write-Host "✅ Tunnel OK: $($activeTunnel.public_url) -> localhost:3389"
              } else {
                Write-Host "⚠️  No active TCP tunnel found, attempting restart..."
                # Relancer ngrok si nécessaire
                Start-Process -FilePath ".\ngrok.exe" -ArgumentList "tcp 3389 --log stdout" -NoNewWindow
                Start-Sleep -Seconds 15
              }
            } catch {
              Write-Host "⚠️  Tunnel check failed: $($_.Exception.Message)"
              # Tentative de relance de ngrok
              try {
                Write-Host "Attempting to restart ngrok..."
                Stop-Process -Name "ngrok" -Force -ErrorAction SilentlyContinue
                Start-Sleep -Seconds 5
                Start-Process -FilePath ".\ngrok.exe" -ArgumentList "tcp 3389 --log stdout" -NoNewWindow
                Start-Sleep -Seconds 15
              } catch {
                Write-Host "Failed to restart ngrok: $($_.Exception.Message)"
              }
            }
          }
          
          # Garder la session Windows active
          try {
            # Simuler une activité pour éviter que la session se mette en veille
            [System.Windows.Forms.SendKeys]::SendWait(" ")
          } catch {
            # Si SendKeys n'est pas disponible, utiliser une autre méthode
            Get-Process | Out-Null
          }
          
          # Attendre 1 minute avant la prochaine vérification
          Start-Sleep -Seconds 60
        }

    - name: Upload connection info
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: rdp-connection-info
        path: rdp_connection_info.txt
        retention-days: 1
